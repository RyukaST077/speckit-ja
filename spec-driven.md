# Specification-Driven Development (SDD)

## 力関係の逆転

何十年もの間、コードこそが主役でした。仕様はコードに従属し、「本当の作業」であるコーディングが始まった途端に足場として捨てられてきました。私たちは開発を導くために PRD を書き、実装を伝えるために設計ドキュメントを作り、アーキテクチャを可視化するためにダイアグラムを描きました。しかし、それらは常にコードに従属していました。コードこそが真実であり、それ以外はせいぜい善意の努力に過ぎませんでした。資産であるコードと実装が一体である以上、コードから独立した並行実装を持つことは容易ではなく、仕様がコードの進化に歩調を合わせることはほとんどありませんでした。

Spec-Driven Development (SDD) は、この力関係を逆転させます。仕様がコードに奉仕するのではなく、コードが仕様に奉仕します。PRD は実装のためのガイドではなく、実装を生成する源泉です。テクニカルプランはコーディングを助けるドキュメントではなく、コードを生み出す厳密な定義です。これはソフトウェアの作り方を少し良くする改善ではありません。開発を駆動するものそのものを、根本から再考するアプローチです。

ソフトウェア開発草創期から、仕様と実装の間のギャップは悩みの種でした。私たちはより良いドキュメント、詳細な要件、厳格なプロセスでその溝を埋めようとしてきました。しかし、それらのアプローチはギャップが避けられないものだと受け入れてしまっているがゆえに失敗します。狭めようとしても、ギャップを消し去ることはできません。SDD は仕様と具体的な実装計画を実行可能なものにすることで、そのギャップを消し去ります。仕様と実装計画がコードを生成するとき、そこにあるのはギャップではなく、仕様からコードへの「変換」だけです。

この変革は、AI が複雑な仕様を理解し、詳細な実装計画を策定できるようになった今だからこそ可能になりました。しかし、構造のないまま AI に生成を任せれば混沌が生じます。SDD は厳密で完全かつ曖昧さのない仕様と実装計画によって、AI による生成を制御します。仕様は主要な成果物となり、コードは特定の言語やフレームワークにおけるその表現 (実装計画から生まれる実装) になります。

この新しい世界では、ソフトウェアを保守することは仕様を進化させることを意味します。開発チームの意図は自然言語による「**意図駆動開発**」、デザイン資産、基本原則などで表現されます。開発の **共通言語 (lingua franca)** はより高いレイヤーに移り、コードは最終段階の表現となります。

デバッグとは、誤ったコードを生成した仕様と実装計画を修正することです。リファクタリングとは、仕様をより明確に再構成することです。開発ワークフロー全体が仕様を唯一の信頼できる情報源とするよう再編され、実装計画とコードは継続的に再生成される成果物になります。新機能を追加したり、創造性のために新しい並行実装を作るときは、仕様を見直し、新しい実装計画を作ります。このプロセスは 0 -> 1, (1', ..), 2, 3, N というステップで繰り返されます。

開発チームは創造性、実験、批判的思考に集中できるようになります。

## 実践における SDD ワークフロー

ワークフローはアイデアから始まります。それはしばしば漠然として不完全です。AI との反復的な対話を通じて、このアイデアは包括的な PRD へと形を変えます。AI は確認すべき質問を投げかけ、エッジケースを洗い出し、明確な受け入れ条件の定義を助けます。伝統的な開発であれば数日の会議とドキュメント作成が必要な作業が、数時間の集中した仕様策定に凝縮されます。これにより従来の SDLC が変革され、要件定義と設計は離れたフェーズではなく継続的な活動になります。これは **チームプロセス** を支援するものであり、チームレビューされた仕様がブランチ上で作成・バージョン管理され、マージされます。

プロダクトマネージャーが受け入れ条件を更新すれば、実装計画は影響を受ける技術的決定を自動で特定します。アーキテクトがより良いパターンを発見すれば、PRD が新しい可能性を反映して更新されます。

仕様策定の過程では、リサーチエージェントが重要なコンテキストを収集します。ライブラリの互換性、性能ベンチマーク、セキュリティへの影響を調査します。組織固有の制約も自動的に取り込まれ、データベース標準、認証要件、デプロイ方針が仕様にシームレスに統合されます。

PRD から AI は、要求を技術的判断へと写像する実装計画を生成します。すべての技術選定には根拠が記録され、すべてのアーキテクチャ判断は明確な要件へと遡れます。このプロセス全体を通じて、一貫性の検証が品質を継続的に高めます。AI は曖昧さ、矛盾、抜け漏れを分析します。それは一度きりのゲートではなく、継続的なブラッシュアップです。

仕様と実装計画が十分安定すればコード生成が始まります。ただし「完全」である必要はありません。初期の生成は探索的なものでもよく、仕様が実際に通用するかを検証する役割を担います。ドメイン概念は API、コマンドラインツール、データモデルとして表現されます。テストは実装計画に紐づけられています。コード生成は、仕様の意図を実装へと変換する作業に過ぎません。この段階での人間の役割は、仕様を改善し続けることで生成されるコードの品質を引き上げることにあります。

## 仕様がコードよりも強力になる

仕様が最も重要な成果物になると、ソフトウェア開発の仕事は根本的に変わります。仕様は単に何かを述べるだけではなく、生成プロセスを駆動する「プログラム」に近いものになります。

- 仕様は構造化されており、すべてのソフトウェア成果物 (コード、テスト、ドキュメントなど) の 1 次ソースです
- 実装計画は仕様を機械が読める形に展開し、コマンド・スクリプト・ライブラリを生成します
- コードは実装計画のラストマイルであり、仕様からの変換でしかありません
- 保守作業とは仕様の改善であり、コードの道具立てではありません

このアプローチは人間と AI の得意分野を組み合わせます。人間は高い抽象度で意図を表現し、AI はその意図を具現化するローレベルの作業を行います。仕様は複雑なシステムを理解するための入り口であり、コードはその具体化です。

仕様の改善は大きな効果をもたらします。要件の曖昧さを取り除けば、生成コードは自動的に明確になります。境界条件を明示すれば、テストによって欠陥が浮き彫りになります。仕様を更新することで、プロダクト・アーキテクチャ・実装すべてが同期して進化します。

## 仕様を第 1 級成果物にするツール

### 1. SDD テンプレート

Spec Kit はあらゆる成果物にテンプレートを提供します。PRD、実装計画、リサーチノート、データモデル、コントラクト、チェックリストなどが含まれます。これらは単なる文書フォーマットではなく、AI が理解して動作するための構造そのものです。テンプレートがあることで仕様は厳密さを保ち、チーム全体で一貫した表現が可能になります。

テンプレートは次のような役割を持ちます。

- 必須セクションを明示し、抜け漏れを防ぐ
- 意図・要件・テスト・検証手順を特定の場所に記述させる
- 実装計画で必要な構造 (フェーズ、ゲート、依存関係など) を定義する
- 生成されるコマンドやタスクがテンプレートに沿って構築されるよう強制する

テンプレートがあることで、仕様は AI にとって「実行可能なプログラム」となり、人間にとっても理解しやすいものになります。

### 2. Specify CLI

Specify CLI は SDD ワークフローを支えるコマンドラインインターフェースです。フィーチャーの初期化、仕様作成、計画生成、タスク一覧作成、実装チェックなどのコマンドを提供します。Specify はテンプレートに基づいた成果物を生成し、AI モデルに与えるコンテキストを整形します。

主な機能:

- 新しいフィーチャーをブランチとともに作成し、必要なテンプレートファイルを配置する
- 仕様作成時にチェックリストを自動生成し、品質を確認する
- Implement/Plan コマンドで分岐したワークフローをサポートする
- さまざまな AI エージェント (Claude、Gemini、Cursor など) に最適化されたコマンドを生成する

Specify によって、仕様ベースの開発フローが再現性を持って実行できます。

### 3. チェックリスト

SDD ではチェッ クリストが重要な役割を果たします。チェックリストは要件の品質を測定するための単体テストのようなものです。チェックリストは仕様の曖昧さや抜け漏れを見つけ、改善すべき箇所を明確にします。

チェックリストは以下のような観点を持ちます。

- 受け入れ条件が明確か
- ユーザーストーリーごとの価値が定義されているか
- 非機能要件が測定可能か
- エッジケースや障害シナリオが網羅されているか
- 依存関係や制約が明示されているか

これにより仕様は継続的に強化され、生成される実装も安定した品質を保ちます。

### 4. プロジェクト憲章

プロジェクト憲章はアーキテクチャ原則を明文化した永続的なガイドラインです。SDD では憲章を仕様そのものに組み込み、実装計画がこれを守るようにします。憲章により、AI が生成するコードであってもプロジェクトの価値基準が守られます。

憲章の例:

- Test-Driven Development を必須とする
- フレームワークの機能を直接利用する (不要なラッパー禁止)
- 簡潔なプロジェクト構成を維持する
- 契約テストを最初に書く

憲章はテンプレートやチェックリスト、スクリプトに組み込まれており、違反するとゲートでブロックされます。

## SDD を支えるアーティファクトの役割

### 仕様 (spec.md)

PRD に相当する仕様は、ユーザー価値を中心に、機能要件・非機能要件・エッジケース・成功指標を体系的に記述します。仕様は SDD における唯一の真実の源泉であり、すべての作業は仕様を更新する形で実行されます。

仕様の重要性:

- すべてのステークホルダーが共通理解を持てる
- エッジケースを先に定義し、後工程での手戻りを減らす
- テストケースやタスクの基礎となる
- 仕様が更新されれば、下流の成果物も再生成されて一貫性が保たれる

仕様では技術的詳細ではなく、ユーザー体験と成功条件に焦点を当てます。どのような価値を誰に届けるのかを明確にし、実装は後段の計画で具体化します。

### 実装計画 (plan.md)

実装計画は仕様から導かれ、技術的な決断と実装手順を詳述します。フェーズ構成、依存関係、テスト戦略、データモデル、コントラクトを明確にします。

実装計画の特徴:

- フェーズごとに細分化され、ゲートによって進行可否が判断される
- 技術スタックの選定理由が明示される
- データモデルや API コントラクトが仕様へ追跡できる
- テスト戦略が TDD を前提に構成される

計画がしっかりしていれば、生成されるタスクとコードの品質も高くなります。

### リサーチ (research.md)

リサーチは仕様や計画で判明した不明点を解消するための調査結果を記録します。フレームワーク選定、パフォーマンス要件、セキュリティへの影響などを検証し、意思決定の根拠を明確にします。

リサーチは次のような役割を持ちます。

- 「なぜこの技術を選んだのか」を文書化する
- 仕様の [NEEDS CLARIFICATION] を解消する
- 実装計画のフェーズ 0 (リサーチフェーズ) を完了させる
- 後から振り返って意思決定を再評価できるようにする

### データモデル (data-model.md)

仕様で定義されたエンティティや関係を整理し、フィールド・キー・バリデーション・状態遷移などを記述します。データモデルは実装計画の骨組みであり、タスクやテストが参照する基盤になります。

### コントラクト (contracts/)

API や外部インターフェースの契約を定義します。OpenAPI や GraphQL スキーマなどで表現され、契約テストの基準となります。SDD では契約テストが実装前に必須なので、コントラクトは非常に重要です。

### タスク (tasks.md)

タスクは実装計画を実行可能なアクションへ分解したものです。フェーズ別・ユーザーストーリー別に整理され、依存関係や並行実行の可否が明示されています。各タスクには具体的なファイルパスが記載され、LLM が迷わずに実行できます。

タスクの構成:

- フェーズ 1: セットアップ
- フェーズ 2: 基盤 (全ストーリーに先立つ作業)
- フェーズ 3 以降: ユーザーストーリーごとの実装
- 最終フェーズ: 仕上げと横断的改善

各タスクはテスト駆動で並べられ、テストが失敗することを確認してから実装に進みます。

## チーム構造への影響

SDD を導入すると、チームの役割とワークフローが変化します。

- プロダクトマネージャーは仕様の品質に責任を持ち、開発者と同じほど仕様作成に関与します
- アーキテクトは実装計画と憲章の整合性にフォーカスし、コードレビューではなく仕様レビューを重視します
- 開発者は実装計画に基づいてタスクを実行し、得られた知見を仕様へフィードバックします
- QA は仕様とタスクを基にテスト戦略を組み立て、生成されたコードに対して仕様レベルのレビューを行います

この結果、チーム全員が仕様を共通言語として活用し、開発のすべての局面で同期できます。

## 指定されたテンプレートの詳細

### 仕様テンプレート

仕様テンプレートには、ユーザーストーリー、エッジケース、機能要件、非機能要件、成功指標などが必須セクションとして定義されています。各セクションには記入方法のガイドが含まれ、意図が明確になるよう構成されています。

- **ユーザーストーリー**: 独立して開発・テスト・デプロイできる機能単位
- **エッジケース**: 境界条件やエラーシナリオを明示
- **要件**: テスト可能な表現で記述 (曖昧語禁止)
- **成功指標**: 測定可能かつ技術非依存のアウトカム

テンプレートは [NEEDS CLARIFICATION] を 3 つ以下に抑えるなどの制約を課し、曖昧さの少ない仕様を書くことを促します。

### 実装計画テンプレート

実装計画はフェーズ構造を持ち、ゲートとチェックリストが組み込まれています。フェーズ -1 では憲章に基づいたゲートを通過しないと先へ進めません。各フェーズ内では依存関係が整理され、タスクの並列実行可否が明示されています。

テンプレート内の主な要素:

- テクニカルコンテキスト (言語、依存関係、ストレージ、テスト、パフォーマンス目標など)
- 憲章チェック (Simple/Anti-Abstraction/Integration などのゲート)
- フェーズ別の成果物 (research, data-model, contracts, quickstart, tasks)
- 複雑性トラッキング (追加の複雑性を正当化する欄)

## 指定された憲章の詳細

### Article I: ライブラリ優先

AI モデルは既存のライブラリを活用し、同じ品質の処理をゼロから実装してはならないと定めています。

```text
1.3
New code can only be written if:
- No existing library provides the functionality
- The new code wraps library functionality without altering behavior
```

これにより、LLM が車輪の再発明をすることなく、テスト済みで信頼できるライブラリを活用できます。

### Article II: CLI 駆動アーキテクチャ

すべての機能が CLI として利用可能であることを義務付けています。

```text
CLI Principle:
- Functions as executable commands (no hidden services)
- Accept text as input (stdin / arguments / files)
- Produce text output (stdout)
- Support JSON for structured data
```

これにより観測性とテスト容易性が確保されます。LLM はブラックボックス的なクラスに機能を隠せず、すべてがテキストベースのインターフェース経由で検証可能になります。

### Article III: テストファーストの必然

最も重要な条文は、テスト駆動開発を絶対条件とする点です。

```text
This is NON-NEGOTIABLE: All implementation MUST follow strict Test-Driven Development.
No implementation code shall be written before:
1. Unit tests are written
2. Tests are validated and approved by the user
3. Tests are confirmed to FAIL (Red phase)
```

これにより、コードを生成してからテストするのではなく、テストで振る舞いを定義し、承認を得てから実装するフローが徹底されます。

### Articles VII & VIII: シンプルさと反抽象主義

過度な抽象化を防ぐための条文です。

```text
Section 7.3: Minimal Project Structure
- Maximum 3 projects for initial implementation
- Additional projects require documented justification

Section 8.1: Framework Trust
- Use framework features directly rather than wrapping them
```

実装計画テンプレートの「Phase -1 Gates」はこれらの原則を直接的に検証します。複雑さを追加する場合は必ず正当化し、記録に残さなければなりません。

### Article IX: 統合テスト優先

現実的な環境でのテストを優先することを定めています。

```text
Tests MUST use realistic environments:
- Prefer real databases over mocks
- Use actual service instances over stubs
- Contract tests mandatory before implementation
```

これにより、生成コードが机上の空論ではなく実運用を前提とした品質を備えます。

### 憲章を実装するテンプレート

実装計画テンプレートは次のようなゲートを備えています。

```markdown
### Phase -1: Pre-Implementation Gates
#### Simplicity Gate (Article VII)
- [ ] Using ≤3 projects?
- [ ] No future-proofing?

#### Anti-Abstraction Gate (Article VIII)
- [ ] Using framework directly?
- [ ] Single model representation?

#### Integration-First Gate (Article IX)
- [ ] Contracts defined?
- [ ] Contract tests written?
```

これらはアーキテクチャ原則のコンパイル時チェックのように機能します。ゲートを通過できない場合は、複雑性トラッキングに正当化を記載しなければなりません。

### 不変の原則がもたらす効果

憲章の強みは「不変であること」にあります。実装の細部は変わっても、根本原則は揺らぎません。

1. **時間を超えた一貫性**: 今日生成したコードも、来年生成するコードも同じ原則に従う
2. **LLM をまたいだ一貫性**: モデルが変わってもアーキテクチャ的に整合したコードが生成される
3. **アーキテクチャの整合性**: 各フィーチャーがシステム設計を強化し、劣化させない
4. **品質保証**: テストファースト、ライブラリ優先、シンプルさの原則が保守性の高いコードを生む

### 憲章の進化

原則は不変ですが、その適用方法は進化できます。

```text
Section 4.2: Amendment Process
Modifications to this constitution require:
- Explicit documentation of the rationale for change
- Review and approval by project maintainers
- Backwards compatibility assessment
```

これにより、経験に基づいて原則の解釈や適用範囲を調整しながらも、基本方針は安定して維持できます。憲章は日付付きの改訂履歴を持ち、実際の運用から得た学びを反映します。

### ルールを超えた開発哲学

憲章は単なるルールブックではなく、LLM がコード生成を考える際の哲学です。

- **観測可能性の重視**: すべてが CLI 経由で観測・検証可能でなければならない
- **シンプルさの重視**: 複雑さは必要なときにのみ導入する
- **統合の重視**: 実環境でテストし、単独の仮想環境に依存しない
- **モジュール性の重視**: 各フィーチャーは明確な境界を持つライブラリとして形成する

これらの原則を仕様と計画に組み込むことで、生成されるコードは単に動くだけではなく、保守性・テスト容易性・アーキテクチャの健全性を備えます。憲章は AI をコード生成ツールではなく、システム設計原則を尊重するアーキテクトへと変貌させます。

## トランスフォーメーション

これは開発者を置き換えたり、創造性を自動化することが目的ではありません。定型的な変換作業を自動化することで人間の能力を増幅することが目的です。仕様・リサーチ・コードが連動しながら進化する、緊密なフィードバックループを構築します。反復を重ねるごとに、意図と実装の整合性が深まります。

ソフトウェア開発に必要なのは、意図と実装の整合性を保つためのツールです。SDD は、仕様を実行可能にし、コードを生成することで、この整合性を実現します。
